# Задание А1

## Код программы 
### Полный код программы можно посмотреть в [файле](experiment.cpp) 
Для удобства работы с точками и их координатами я сделал класс `Point`, в котором есть конструктор и два публичных поля - координаты `x` и `y`.
```cpp
class Point {
public:
    double x;
    double y;

    Point(double x, double y) {
        this->x = x;
        this->y = y;
    }
};
```

Далее идёт метод `generatePoints()`, который принимает целое число **N** и возвращает вектор из **N** точек со случайно сгенерированными координатами `x` и `y`.
```cpp
std::vector<Point> generatePoints(int N) {
    std::random_device rd;
    std::mt19937 gen(rd());
    std::uniform_real_distribution<> dis(-1.0, 1.0);

    std::vector<Point> points;

    for (int i = 0; i < N; ++i) {
        double x = dis(gen);
        double y = dis(gen);

        Point point = Point(x, y);
        points.push_back(point);
    }

    return points;
}
```
Для подсчёта числа **M**(числа точек, которые находятся внутри круга радиусом 1 и центром в начале координат) используется метод `countM()`, который принимает вектор из точек и возвращает целое число **M**. 
```cpp
int countM(const std::vector<Point>& points) {
    int M = 0;
    for (auto point : points) {
        if (point.x * point.x + point.y * point.y <= 1) {
            M++;
        }
    }
    return M;
}
```
Для проведения самого эксперимента применяется метод `experiment()`, в котором написан цикл для перебора нужного количества сгенированных точек(от 100 до 5000 с шагом 100). На каждой итерации цикла генерируется массив из точек при помощи метода `generatePoints()` длины **N**, подсчитывается число **M** с помощью метода `countM()` и наконец-то считается результат - приблизительное значение числа **pi** формулой `pi = 4M / N`.
```cpp
void experiment() {
    for (int N = 100; N <= 5000; N += 100) {
        std::vector<Point> points = generatePoints(N);
        int M = countM(points);

        double pi = (4.0 * M) / N;
        std::cout << N << " " << pi << "\n";
    }
}
```

## Анализ результатов 
### Excel-файл, в котором я строил все графики и в котором приведены полученные из программы данные можно посмотреть [тут](A1.xlsx).
Для начала я запустил программу один раз и получил следующие значения числа **pi** при каждом **N**:

```
N	pi
100	3,28
200	3,28
300	3,09
400	3,07
500	3,22
600	3,05
700	3,23
800	3,16
900	3,11
1000	3,10
1100	3,16
1200	3,10
1300	3,18
1400	3,15
1500	3,12
1600	3,16
1700	3,14
1800	3,15
1900	3,09
2000	3,08
2100	3,17
2200	3,09
2300	3,11
2400	3,06
2500	3,13
2600	3,17
2700	3,19
2800	3,12
2900	3,13
3000	3,16
3100	3,12
3200	3,14
3300	3,13
3400	3,11
3500	3,16
3600	3,14
3700	3,15
3800	3,14
3900	3,14
4000	3,16
4100	3,18
4200	3,14
4300	3,12
4400	3,13
4500	3,16
4600	3,11
4700	3,17
4800	3,15
4900	3,17
5000	3,15
```

Теперь на графиках рассмотрим результаты подсчёта приблизительного значения числа **pi**.

1. Сначала, **График №1** - он показывает, как изменяется вычисленное значение числа **pi** в зависимости от количества сгенерированных точек **N**.
   ![Без заголовка](https://github.com/flowykk/algorithms-hse/assets/71427624/3a800419-d0d2-4315-ace0-23ee20b1d920)
   По этому графику можно легко сделать вывод о том, что чем больше **N** - тем ближе вычисленный программой результат к абсолютному значению числа **pi**. Именно поэтому кривая на графике приближается к прямой `y = 3,14159...`.
   
2. Теперь, **График №2**, который отображает, как изменяется относительное отклонение (в %) приближенного значения числа **pi** от точного в зависимости от общего числа точек **N**.
   Для построения этого графика я в Excel посчитал нужное отклонение при помощи формулы `=(ABS(Bx-ПИ())/ПИ()) * 100` в каждой строке и получил следующие результаты:
    ```
    N	pi	отклонение pi
    100	3,28	4,406
    200	3,28	4,406
    300	3,09	1,536
    400	3,07	2,279
    500	3,22	2,623
    600	3,05	2,809
    700	3,23	2,769
    800	3,16	0,427
    900	3,11	1,112
    1000	3,10	1,324
    1100	3,16	0,470
    1200	3,10	1,324
    1300	3,18	1,370
    1400	3,15	0,222
    1500	3,12	0,687
    1600	3,16	0,586
    1700	3,14	0,088
    1800	3,15	0,162
    1900	3,09	1,625
    2000	3,08	2,088
    2100	3,17	0,828
    2200	3,09	1,497
    2300	3,11	0,853
    2400	3,06	2,544
    2500	3,13	0,382
    2600	3,17	1,027
    2700	3,19	1,670
    2800	3,12	0,551
    2900	3,13	0,424
    3000	3,16	0,586
    3100	3,12	0,811
    3200	3,14	0,210
    3300	3,13	0,456
    3400	3,11	0,912
    3500	3,16	0,659
    3600	3,14	0,015
    3700	3,15	0,276
    3800	3,14	0,151
    3900	3,14	0,002
    4000	3,16	0,586
    4100	3,18	1,331
    4200	3,14	0,172
    4300	3,12	0,599
    4400	3,13	0,456
    4500	3,16	0,473
    4600	3,11	0,881
    4700	3,17	0,911
    4800	3,15	0,374
    4900	3,17	1,002
    5000	3,15	0,280
    ```
    А вот и сам **График №2**, построенный во 3-ём вышеуказанным столбцам.
   ![Без заголовка](https://github.com/flowykk/algorithms-hse/assets/71427624/b889bb7b-3be6-4616-96e0-ee39d9f2870f)
   Здесь при росте числа **N** график всё больше и больше приближается к 0. Это происходит, потому что вычисленный результат становится всё точнее и точнее с ростом количества сгенерированных точек, а значит и разница между вычисленным и абсолютным значениями числа **pi**.

## Вывод
Из двух графиков можно сделать следующий вывод: с ростом числа **N** растёт количество точек, которые попадут в нужный круг (число **M**), и растёт число точек, которые попадут в простравнство между кругом и границей квадрата - то есть при росте числа **N** вычисления становятся всё точнее и точнее.
